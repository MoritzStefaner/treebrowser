package eu.stefaner.organicedunet.semanticsearch.treeexplore_vertical {	import eu.stefaner.organicedunet.semanticsearch.EdgeData;	import eu.stefaner.organicedunet.semanticsearch.NodeData;	import eu.stefaner.organicedunet.semanticsearch.OEVisualization;	import flare.animate.TransitionEvent;	import flare.animate.Transitioner;	import flare.util.Maths;	import flare.util.Orientation;	import flare.util.Vectors;	import flare.vis.axis.Axes;	import flare.vis.data.Data;	import flare.vis.data.DataList;	import flare.vis.data.EdgeSprite;	import flare.vis.data.NodeSprite;	import flare.vis.operator.layout.NodeLinkTreeLayout;	import flare.vis.operator.layout.RadialTreeLayout;	import org.osflash.thunderbolt.Logger;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.Dictionary;	/**	 * @author mo	 */	public class TreeExploreVisualization extends OEVisualization {		private static const FAT_LINES : Boolean = false;		private var visibilityFilter : OEVisibilityFilter;		private var radialLayout : Boolean = true;		private var edgeDefaults : Object;		private var nodeDefaults : Object;		public var focusPoint : Point = new Point();		private var firstRun : Boolean = true;		public var totalHeight : Number;		public var transitioner : Transitioner;		private var relatedNodes : Dictionary = new Dictionary(true);		private var relatedNodesVisible : Boolean;		private var debugSprite : Sprite;
		public function TreeExploreVisualization(data : Data = null, axes : Axes = null) {			super(data, axes);		}		override protected function initRelations() : void {			edgeDefaults = {};			//edgeDefaults.lineColor = 0xFF7DA541;			edgeDefaults.lineColor = function(e : *) :uint {				return (e.data && e.data.type) ? EdgeData.getColorForType(e.data.type) : 0xFF7DA541;			};						edgeDefaults.visible = false;			//edgeDefaults.lineWidth = .5;			edgeDefaults.renderer = VerticalCurvedLineRenderer.instance;			data.edges.setDefaults(edgeDefaults);			data.edges.setProperties(edgeDefaults); 		}		override protected function initNodes() : void {			nodeDefaults = {};			nodeDefaults.visible = false;			nodeDefaults.shape = null;			nodeDefaults.size = 1;						data.nodes.setDefaults(nodeDefaults); 			data.nodes.setProperties(nodeDefaults);		}		override protected function initLayout() : void {			visibilityFilter = new OEVisibilityFilter(null, 1);			operators.add(visibilityFilter);						//			if(radialLayout) {				var layout : RadialTreeLayout = new RadialTreeLayout();				layout.useNodeSize = true;				layout.autoScale = false;				layout.sortAngles = false;				layout.radiusIncrement = 140;				layout.angleWidth = Math.PI * .85;				layout.startAngle = Math.PI * .5 + layout.angleWidth * .5 ;				layout.layoutRoot = data.root;				layout.layoutAnchor = new Point(bounds.width * .5, bounds.height);				this.layout = layout;			} else {				this.layout = new NodeLinkTreeLayout(Orientation.BOTTOM_TO_TOP, 50, 5, 10);			}						//layout = new IcicleTreeLayout(Orientation.TOP_TO_BOTTOM);			operators.add(this.layout);			/*			var dragControl : PanZoomControl = new PanZoomControl();			controls.add(dragControl);			 * 			 */			/*			var dragControl : DragControl = new DragControl(Node);			controls.add(dragControl);			 * 			 */		}		override public function changeSelection(node : NodeSprite) : void {						super.changeSelection(node);			data.nodes.setProperties({selected:false, size:1});			(selectedNode as Node).selected = true;			var t : Transitioner = new Transitioner(.5);			data.nodes.setProperties({scale:1}, t);			t.$(selectedNode).scale = 1.5;			t.$(selectedNode).alpha = 1;			selectedNode.size = 2;			t.play();			// refreshView();		}		override public function refreshView() : void {			if(transitioner && transitioner.running) {				transitioner.stop();			}						transitioner = new Transitioner(1);						if(firstRun) {				firstRun = false;				transitioner.immediate = true;			}						transitioner.addEventListener(TransitionEvent.STEP, onAnimationStep, false, 0, true);			visibilityFilter.focusNodes = Vectors.copyFromArray([selectedNode]);						data.nodes.setProperties(nodeDefaults, transitioner);			data.edges.setProperties(edgeDefaults, transitioner);						if(radialLayout) {				(layout as RadialTreeLayout).layoutRoot = data.root;			}						update(transitioner);						updateFocusPoint(transitioner);						updateNodes(transitioner);			adjustLineWeights(data.root);			adjustChildEdgeShifts(data.root);			updateOwnPosition(transitioner);			transitioner.play();		}		private function onAnimationStep(event : TransitionEvent) : void {			/*			graphics.clear();			var b:Rectangle=getBounds(parent);			graphics.beginFill(0,.1);			graphics.drawRect(b.left, b.top, b.width, b.height);			Logger.info("bounds", b);			 * 			 */			dispatchEvent(new Event(ANIMATION_STEP));		}		private function updateOwnPosition(t : Transitioner) : void {			//t.$(data.root).y = bounds.height + 30;			t.$(this).x = bounds.width * .5 - focusPoint.x ;			t.$(this).y = Math.max(0, stage.stageHeight * .5 - focusPoint.y + 100 * Number(relatedNodesVisible));			//Logger.info("fp.y", focusPoint.y);			updateTotalHeight();			}		public function updateTotalHeight() : void {			totalHeight = -selectedNode.y + stage.stageHeight + 100 * Number(relatedNodesVisible);		}		private function updateFocusPoint(t : Transitioner) : void {			var oldAngle : Number = selectedNode.angle;			var oldRadius : Number = selectedNode.radius;						selectedNode.radius = t.$(selectedNode).radius;			selectedNode.angle = t.$(selectedNode).angle;			focusPoint.x = selectedNode.x;			focusPoint.y = selectedNode.y;						selectedNode.angle = oldAngle;			selectedNode.radius = oldRadius;		}		private function updateNodes(t : Transitioner) : void {			var breadcrumbLineColor : uint = 0xFF655245;						for each(var n:NodeSprite in data.nodes) {				addChild(n);				t.$(n).alpha = 1;				if(selectedNode == n) {					// selected				} 				if(visibilityFilter.breadcrumbNodes.contains(n)) {					// breadcrumb					if(n.parentEdge) t.$(n.parentEdge).lineColor = breadcrumbLineColor;				} else if(visibilityFilter.childNodes.contains(n)) {					// child					if(n.alpha == 0) {						n.x = focusPoint.x;						n.y = focusPoint.y;					}				/*				} else if(visibilityFilter.relatedNodes.contains(n)) {					// related					//t.$(n).alpha = 0;					addRelatedNode(n, relatedCounter++, visibilityFilter.relatedNodes.length, t);					//doRadialLayout(n, relatedCounter++, visibilityFilter.relatedNodes.length, t);					 * 					 */				} else {					t.$(n).alpha = .2;				}			}			showRelatedNodes(t);			fixOverlaps(t);		}		private function fixOverlaps(t : Transitioner) : void {			var dl : DataList = visibilityFilter.childNodes;			for each(var ns:Node in dl) {				var oldX : Number = ns.x;				var oldY : Number = ns.y;				ns.angle = t.$(ns).angle;				ns.radius = t.$(ns).radius;				t.$(ns).x = ns.x;				t.$(ns).y = ns.y;				ns.x = oldX;				ns.y = oldY;			}			var moveDirection : Number = -1;			var alreadyProcessed : Array = [];			for each(ns in dl) {				var overlaps : Boolean = true;				moveDirection *= -1;				while (overlaps) {					overlaps = false;					for each(var ns2:Node in alreadyProcessed) {						var b1 : Rectangle = getEndBounds(t, ns);						var b2 : Rectangle = getEndBounds(t, ns2);						if(b1.intersects(b2)) {							overlaps = true;							t.$(ns).y = t.$(ns).y + moveDirection; 							break;						}							}				}				var oldX : Number = ns.x;				var oldY : Number = ns.y;				ns.x = t.$(ns).x;				ns.y = t.$(ns).y;				t.$(ns).angle = ns.angle;				t.$(ns).radius = ns.radius;				ns.x = oldX;				ns.y = oldY;				alreadyProcessed.push(ns);			}			/*			if(!debugSprite) {				debugSprite = new Sprite();				debugSprite.mouseEnabled = false;			}			addChild(debugSprite);			debugSprite.graphics.clear();			debugSprite.graphics.beginFill(0, .33);			for each(ns in dl) {				var n : Rectangle = getEndBounds(t, ns);				debugSprite.graphics.drawRect(n.left, n.top, n.width, n.height);			}			 * 			 */		}		private function getEndBounds(t : Transitioner, ns : Node) : Rectangle {			return new Rectangle(t.$(ns).x - ns.label_tf.width * .5, t.$(ns).y - ns.label_tf.height * .5, ns.label_tf.width, ns.label_tf.height);		}		private function showRelatedNodes(t : Transitioner) : void {			for each(var rn:RelatedNode in relatedNodes) {				t.$(rn).alpha = 0;				rn.relationTypes = [];				rn.visible = false;				rn.props.willBeVisible = false;			}						var numRelatedNodes : int = 0;			selectedNode.visitEdges(function(e : EdgeSprite) {				if(!e.props.isRelationEdge) {					var ns2 : NodeSprite = e.other(selectedNode);					if(!relatedNodes[ns2]) {						relatedNodes[ns2] = addRelatedNode(ns2);					}						var rn : RelatedNode = relatedNodes[ns2];						if(!rn.props.willBeVisible) {						numRelatedNodes++;						rn.props.willBeVisible = true;					}					createRelationEdge(e, selectedNode, rn, t);					rn.relationTypes.push((e.data as EdgeData).label);				}			}, NodeSprite.GRAPH_LINKS);						var index : int = 0;			for each(var rn:RelatedNode in relatedNodes) {				if(!rn.props.willBeVisible) continue;				rn.updateRelationLabel();				rn.visible = true;				doRadialLayout(rn, index, numRelatedNodes, t);				index++;				t.$(rn).alpha = .75;				t.$(rn).visible = true;			}			relatedNodesVisible = index > 0;		}		private function createRelationEdge(e : EdgeSprite, selectedNode : NodeSprite, ns2 : NodeSprite, t : Transitioner) : void {			var e2 : EdgeSprite; 			selectedNode.visitEdges(function(e3 : EdgeSprite) {				if(e3.other(selectedNode) == ns2) {					e2 = e3;				}			});						if(!e2) {				e2 = data.addEdgeFor(selectedNode, ns2, null);				e2.props.isRelationEdge = true;				data.edges.applyDefaults(e2);			}						e2.visible = true;			t.$(e2).alpha = .3;			t.$(e2).visible = true;		}		private function addRelatedNode(n : NodeSprite) : RelatedNode {			var rn : RelatedNode = new RelatedNode(NodeData(n.data), n);			data.addNode(rn);			data.nodes.applyDefaults(rn);			return rn;		}		private function doRadialLayout(n : NodeSprite, index : Number, totalNum : int, t : Transitioner) : void {			Logger.info("doRadialLayout", index, totalNum);			var angleWidth : Number = Math.PI * .75;			var startAngle : Number = -t.$(selectedNode).angle - angleWidth * .5;			//var startAngle : Number = -Math.PI * .5 - angleWidth * .5;			var radius : Number = 150 + 100 * Number(selectedNode.childDegree > 0);			var a : Number = Maths.linearInterp((index + 1) / (totalNum + 1), startAngle, startAngle + angleWidth);			t.$(n).x = focusPoint.x + Math.cos(a) * radius;			t.$(n).y = focusPoint.y + Math.sin(a) * radius;		}		private function adjustLineWeights(n : NodeSprite) : Number {			if(n.childDegree) {				var lineWeight : Number = 0;				n.visitEdges(function(e : EdgeSprite):void {					if(FAT_LINES) {						e.lineWidth = adjustLineWeights(e.other(n));					} else {						e.lineWidth = Math.sqrt(adjustLineWeights(e.other(n)));					}					lineWeight += e.lineWidth;				}, NodeSprite.CHILD_LINKS);				return lineWeight;			} else {				return .5;			}		}		private function adjustChildEdgeShifts(n : NodeSprite) : void {			var totalLineWidth : Number = 0;			var minWidth : Number = .25;			n.visitEdges(function(e : EdgeSprite):void {				totalLineWidth += Math.max(minWidth, e.lineWidth);			}, NodeSprite.CHILD_LINKS);						var currentYPos : Number = -.5 * totalLineWidth;			n.visitEdges(function(e : EdgeSprite):void {				e.props.shiftX1 = currentYPos + .5 * Math.max(minWidth, e.lineWidth);				currentYPos += Math.max(minWidth, e.lineWidth);				adjustChildEdgeShifts(e.other(n));			}, NodeSprite.CHILD_LINKS);		}	}}